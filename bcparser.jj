options {

}

PARSER_BEGIN(BCParser)

import java.io.*;

public class BCParser {
    public static void main (String args[]) {
        StringReader programa = new StringReader(args[0]);
        BCParser parser = new BCParser(programa);

        try {
            //parser.lexicalAnalizer();
            parser.bc();
            System.out.println("Programa analisado com sucesso");
        } catch (ParseException e) {
            System.out.println(e.getMessage());
        }
    }
}

PARSER_END(BCParser)

SKIP:
{
    " "
|   "\t"
|   "\r"
|   < "#" (~["\r", "\n"])* >
|   < "/*" > : ML_COMMENT_STATE
}

<ML_COMMENT_STATE> SKIP:
{
    < "*/" > : DEFAULT
|   < ~[] >
}

TOKEN:
{
    <SEMICOLON: ";">
|   <LRBRACK: "(">
|   <RRBRACK: ")">
|   <LBRACK: "[">
|   <RBRACK: "]">
|   <LCBRACK: "{">
|   <RCBRACK: "}">
|   <ASSIGN: "=">
|   <COMMA: ",">
|   <DOT: ".">
|   <BACKSLASH: "\\">
|   <QUOTE: "\"">
|   <LINEBREAK: "\n">
}

TOKEN:
{
    <IBASE: "ibase">
|   <OBASE: "obase">
|   <LAST: "last" | <DOT>>
|   <IF: "if">
|   <ELSE: "else">
|   <WHILE: "while">
|   <FOR: "for">
|   <NULL: "null">
|   <BREAK: "break">
|   <CONTINUE: "continue">
|   <QUIT: "quit">
|   <PRINT: "print">
|   <RETURN: "return">
|   <DEFINE: "define">
|   <AUTO: "auto">
|   <FUNCS: "s">
|   <FUNCC: "c">
|   <FUNCE: "e">
|   <FUNCL: "l">
|   <FUNCA: "a">
|   <FUNCJ: "j">
|   <SQRT: "sqrt">
|   <LENGTH: "length">
|   <SCALE: "scale">
}

TOKEN:
{
    <PLUS: "+">
|   <MINUS: "-">
|   <DIV: "/">
|   <MUL: "*">
|   <MOD: "%">
|   <PLUSPLUS: "++">
|   <MINUSMINUS: "--">
|   <POWER: "^">
|   <AND: "&&">
|   <OR: "||">
|   <NOT: "!">
|   <GREATER: ">">
|   <LESSER: "<">
|   <EQUAL: "==">
|   <GREATEREQ: ">=">
|   <LESSEREQ: "<=">
|   <NOTEQ: "!=">
|   <PLUSASSIGN: "+=">
|   <MINUSASSIGN: "-=">
|   <DIVASSIGN: "/=">
|   <MULASSIGN: "*=">
|   <MODASSIGN: "%=">
|   <POWASSIGN: "^=">
}

TOKEN:
{
    <#DIGITS: ["0"-"9"]>
|   <#LETTERS: ["a"-"z"]  | "_">
|   <#FLOAT: ("-" | "+")? (<DIGITS>)+ "." (<DIGITS>)+>
|   <#INTEGER: ("-" | "+")? (<DIGITS>)+>
|   <#LETTERSNUMBERS: <DIGITS> | <LETTERS>>
|   <#SYMBOLS: " " | <NOT> | "%" | "&" | "'" | "(" | ")" | "*" | "+" | "," | "-" | "." | "/" | ":" | ";" | <LESSER> | <ASSIGN> | <GREATER>  | "[" | "]" | "^" | "{" | "|" | "}">
|   <NUMBERS: <INTEGER> | <FLOAT>>
|   <ID: <LETTERS> (<LETTERSNUMBERS>)*>
|   <STRING: <QUOTE>(<LETTERSNUMBERS> | <SYMBOLS> | <SEMICOLON> | <LINEBREAK>)*<QUOTE>>
}

void bc():
{ }
{
  (COMMAND() | DEFINEFUNCTION())+ <EOF> {System.out.println("Found BC");}
}

void SEP():
{ }
{
    (<SEMICOLON> | <LINEBREAK>)+
}

void COMMAND():
{ }
{
    E() {System.out.println("Found E()");}
|   COMPOST_COMMAND() {System.out.println("Found COMPOST_COMMAND");}
|   COMMAND_IF() {System.out.println("Found COMMAND_IF");}
|   COMMAND_WHILE() {System.out.println("Found COMMAND_WHILE");}
|   COMMAND_FOR() {System.out.println("Found COMMAND_FOR");}
|   COMMAND_NULL() {System.out.println("Found COMMAND_NULL");}
|   COMMAND_BREAK() {System.out.println("Found COMMAND_BREAK");}
|   COMMAND_CONTINUE() {System.out.println("Found COMMAND_CONTINUE");}
|   COMMAND_QUIT() {System.out.println("Found COMMAND_QUIT");}
|   COMMAND_PRINT() {System.out.println("Found COMMAND_PRINT");}
|   COMMAND_STRING() {System.out.println("Found COMMAND_STRING");}
|   COMMAND_RETURN() {System.out.println("Found COMMAND_RETURN");}
}

void COMPOST_COMMAND():
{ }
{
    <LCBRACK> COMMANDLIST() <RCBRACK>
}

void COMMAND_IF():
{ }
{
    <IF> <LRBRACK> E() <RRBRACK> COMMAND() (LOOKAHEAD(2) <ELSE> COMMAND())?
}

void COMMAND_WHILE():
{ }
{
    <WHILE> <LRBRACK> E() <RRBRACK> COMMAND()
}

void COMMAND_FOR():
{ }
{
    <FOR> <LRBRACK> (E())? <SEMICOLON> (E())? <SEMICOLON> (E())? <RRBRACK> COMMAND()
}

void COMMAND_NULL():
{ }
{
    SEP()
}

void COMMAND_BREAK():
{ }
{
    <BREAK>
}

void COMMAND_CONTINUE():
{ }
{
    <CONTINUE>
}

void COMMAND_QUIT():
{ }
{
    <QUIT>
}

void COMMAND_PRINT():
{ }
{
    <PRINT> EXPRESSIONLIST()
}

void COMMAND_STRING():
{ }
{
    <STRING>
}

void COMMAND_RETURN():
{ }
{
    <RETURN> (<LRBRACK> (E())? <RRBRACK> | (E())?)
}

void COMMANDLIST():
{ }
{
    COMMAND() (SEP() COMMAND())*
}

void EXPRESSIONLIST():
{ }
{
    E() (<COMMA> E())*
}

void E():
{ }
{
    E1() (<OR> E1())* {System.out.println("Found E1");}
}

void E1():
{ }
{
    E2() (<AND> E2())* {System.out.println("Found E2");}
}

void E2():
{ }
{
    (<NOT>)? E3() {System.out.println("Found E3");}
}

void E3():
{ }
{
    E4() ((<EQUAL> | <LESSEREQ> | <GREATEREQ> | <NOTEQ> | <LESSER> | <GREATER>) E4())?  {System.out.println("Found E4");}
}

void E4():
{ }
{
    (
        <ID> (<LBRACK> E() <RBRACK>)? ((<PLUSPLUS> | <MINUSMINUS>) |
                                                             ((<ASSIGN>
                                                            |  <PLUSASSIGN>
                                                            |  <MINUSASSIGN>
                                                            |  <MULASSIGN>
                                                            |  <DIVASSIGN>
                                                            |  <MODASSIGN>
                                                            |  <POWASSIGN>) E4()))
    )
|   E5()  {System.out.println("Found E5");}
}

void E5():
{ }
{
    E6() (LOOKAHEAD(2)(<PLUS> | <MINUS>) E6())*  {System.out.println("Found E6");}
}

void E6():
{ }
{
    E7() ((<MUL> | <DIV> | <MOD>) E7())*  {System.out.println("Found E7");}
}

void E7():
{ }
{
    E8() (<POWER> E7())?  {System.out.println("Found E8");}
}

void E8():
{ }
{
    (<MINUS>)? E9()  {System.out.println("Found E9");}
}

void E9():
{ }
{
    ((<PLUSPLUS> | <MINUSMINUS>) <ID> (<LBRACK> E() <RBRACK>)?) | E10()  {System.out.println("Found E10");}
}

void E10():
{ }
{
    <NUMBERS> {System.out.println("Found NUMBER");}
|   (<LRBRACK>) E() (<RRBRACK>) {System.out.println("Found (E)");}
|   (<SQRT> (<LRBRACK>) E() (<RRBRACK>)) {System.out.println("Found Sqrt");}
|   (<LENGTH> (<LRBRACK>) E() (<RRBRACK>)) {System.out.println("Found Length");}
|   (<SCALE> (LOOKAHEAD(2) (<LRBRACK>) E() (<RRBRACK>))?) {System.out.println("Found Scale");}
|   LOOKAHEAD(2) CALLFUNCTION() {System.out.println("Found CALLFUNCTION");}
|   (<ID> (<LBRACK> E() <RBRACK>)?)  {System.out.println("Found ID");}
|   <IBASE> {System.out.println("Found IBASE");}
|   <OBASE> {System.out.println("Found OBASE");}
|   <LAST> {System.out.println("Found LAST");}
|   (<FUNCS> (<LRBRACK>) E() (<RRBRACK>))
|   (<FUNCC> (<LRBRACK>) E() (<RRBRACK>))
|   (<FUNCE> (<LRBRACK>) E() (<RRBRACK>))
|   (<FUNCL> (<LRBRACK>) E() (<RRBRACK>))
|   (<FUNCA> (<LRBRACK>) E() (<RRBRACK>))
|   (<FUNCJ> (<LRBRACK>) E() (<RRBRACK>) <COMMA> (<LRBRACK>) E() (<RRBRACK>))
}

void CALLFUNCTION():
{ }
{
    <ID> <LRBRACK> (EXPRESSIONLIST())? <RRBRACK>
}

void DEFINEFUNCTION():
{ }
{
    <DEFINE> <ID> <LRBRACK> (VARLIST())? <RRBRACK> <LCBRACK>
    (<AUTO> VARLIST())?
    COMMANDLIST() <RCBRACK>
}

void VARLIST():
{ }
{
    <ID> ((<LBRACK>) (<RBRACK>))? (<COMMA> <ID> ((<LBRACK>) (<RBRACK>))?)*
}

JAVACODE void lexicalAnalizer()
{
    try {
        Token t = getNextToken();

        while(t.kind != 0) {
            System.out.println("\t (" + t.beginLine + ", " + t.beginColumn + "): " + t.image + " - " + tokenImage[t.kind]);
        t = getNextToken();
    }
  } catch (TokenMgrError error) {
    System.out.println(error.getMessage());
  }
}
